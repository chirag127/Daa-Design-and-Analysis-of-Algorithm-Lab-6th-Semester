wetechatu@gmail.com
12. Sort a given set of n integer elements using Merge Sort method and compute its time complexity. Run the program for
varied values of n> 5000, and record the time taken to sort. Plot a graph of the time taken versus non graph sheet. The
elements can be read from a file or can be generated using the random number generator. Demonstrate how the divide
and- conquer method works along with its time complexity analysis: worst case, average case and best case.
The time complexity of the merge sort algorithm is O(nlog(n)). In the worst case scenario, all elements are in reverse order and it takes O(nlog(n)) comparisons to sort them. In the best case scenario, the elements are already sorted and it takes O(n) comparisons to sort them. In the average case, it takes O(n*log(n)) comparisons.

To implement the merge sort algorithm, the given set of elements is first divided into two equal halves, and then each half is sorted recursively using the same algorithm. Finally, the two sorted halves are merged to obtain the final sorted set. The divide and conquer approach is used in the implementation of the merge sort algorithm.




wetechatu@gmail.com
 Sort a given set of n integer elements using Merge Sort method and compute its time complexity using c language
Here is an example implementation of the merge sort algorithm in C language:

scss
Copy code
#include <stdio.h>

void merge(int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 =  r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1+ j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2)
    {
        if (L[i] <= R[j])
        {
            arr[k] = L[i];
            i++;
        }
        else
        {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1)
    {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2)
    {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r)
{
    if (l < r)
    {
        int m = l+(r-l)/2;

        mergeSort(arr, l, m);
        mergeSort(arr, m+1, r);

        merge(arr, l, m, r);
    }
}

int main()
{
    int arr[] = {12, 11, 13, 5, 6, 7};
    int arr_size = sizeof(arr)/sizeof(arr[0]);

    printf("Given array is \n");
    for (int i=0; i < arr_size; i++)
        printf("%d ", arr[i]);

    mergeSort(arr, 0, arr_size - 1);

    printf("\nSorted array is \n");
    for (int i=0; i < arr_size; i++)
        printf("%d ", arr[i]);
    return 0;
}
This implementation has a time complexity of O(n*log(n)). The time taken to sort the elements will depend on the size of the input and the performance of the computer it is running on. To plot a graph of the time taken versus the number of elements, you can write a program to generate a large set of random numbers and measure the time taken to sort it using the merge sort algorithm. You can repeat the process for different sizes of input and plot the resulting data points on a graph.




wetechatu@gmail.com
Run the program for
varied values of n> 5000, and record the time taken to sort. Plot a graph of the time taken versus non graph sheet.
To plot a graph of the time taken to sort versus the number of elements, you can write a program to measure the time taken to sort different sizes of input using the merge sort algorithm. Here is an example implementation in C language to plot the graph:

scss
Copy code
#include <stdio.h>
#include <time.h>

void merge(int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 =  r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1+ j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2)
    {
        if (L[i] <= R[j])
        {
            arr[k] = L[i];
            i++;
        }
        else
        {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1)
    {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2)
    {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r)
{
    if (l < r)
    {
        int m = l+(r-l)/2;

        mergeSort(arr, l, m);
        mergeSort(arr, m+1, r);

        merge(arr, l, m, r);
    }
}

int main()
{
    int n;
    printf("Enter the value of n: ");
    scanf("%d", &n);
    int arr[n];

    srand(time(0));
    for (int i = 0; i < n; i++)
        arr[i] = rand() % 100;

    clock_t t;
    t = clock();
    mergeSort(arr, 0, n - 1);
    t = clock() - t;

    printf("Time taken to sort %d elements using Merge Sort: %f seconds\n", n, ((double)t)/CLOCKS_PER_SEC);
    return 0;
}
This implementation measures the time taken to sort an array of n elements using the merge sort algorithm. You can run the program for different values of n greater than 5000 and record the time taken to sort. To plot the graph, you can create a spreadsheet with two columns, one for the number of elements and another for the time taken to sort. You can then plot the data




wetechatu@gmail.com
Plot a graph of the time taken versus non graph sheet using python
You can use Python's matplotlib library to plot the graph of the time taken to sort versus the number of elements. Here's an example:

less
Copy code
import random
import time

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]
        merge_sort(left)
        merge_sort(right)

        i = j = k = 0

        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                j += 1
            k += 1

        while i < len(left):
            arr[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            arr[k] = right[j]
            j += 1
            k += 1

if __name__ == "__main__":
    import matplotlib.pyplot as plt

    n = 5000
    x = []
    y = []
    for i in range(100, n+100, 100):
        arr = [random.randint(0, 100) for j in range(i)]
        start_time = time.time()
        merge_sort(arr)
        end_time = time.time()
        x.append(i)
        y.append(end_time - start_time)

    plt.plot(x, y)
    plt.xlabel('Number of Elements')
    plt.ylabel('Time Taken (in seconds)')
    plt.title('Merge Sort Time Complexity')
    plt.show()
This code implements the merge sort algorithm and measures the time taken to sort an array of n elements. The time complexity is plotted against the number of elements. The matplotlib library is used to plot the graph with the number of elements on the x-axis and the time taken to sort on the y-axis.




wetechatu@gmail.com
Demonstrate how the divide
and- conquer method works along with its time complexity analysis: worst case, average case and best case.

The divide and conquer method works by dividing a large problem into smaller subproblems and solving each subproblem independently. In the case of merge sort, the method involves dividing an array into two halves until each subarray contains only one element. The subarrays are then merged back together in a sorted manner, hence the name "merge sort".

The worst-case time complexity of merge sort is O(n * log n), where n is the number of elements in the array. This occurs when the array is sorted in the reverse order and each subarray has to be compared multiple times during the merging process.

The average-case time complexity of merge sort is also O(n * log n). This occurs when the elements in the array are randomly ordered, resulting in an average number of comparisons during the merging process.

The best-case time complexity of merge sort is O(n * log n), which occurs when the array is already sorted and there is minimal work required during the merging process.

In conclusion, merge sort has a time complexity of O(n * log n) in all cases, making it a reliable and efficient sorting algorithm.